### 匿名对象

> 什么是匿名对象？即没有名字的对象，匿名对象没有引用,用一次就直接成垃圾了。

**应用场景：** 

1.调用方法的时候，仅仅只能调用一次

- 好处：节省代码
- 注意：要多次调用的时候，最好不用，匿名对象调用完就变成垃圾，可以被垃圾回收

2.匿名对象可以作为实际参数

匿名对象的应用场景：举例（盘里装气球，匿名对象相当于没有线,但是占用内存)

![image-20210916151810751](E:\Typora图片仓库\image-20210916151810751.png)

------

### 封装

<font color='cornflowerblue'>概述</font>：封装是指隐藏对象的属性和行为的细节，仅对外提供公共的访问方式

<font color='cornflowerblue'>好处：</font>

- 隐藏实现细节，提供对外的公共的访问方式
- 挺高了代码的复用性
- 提高了安全性

<font color='cornflowerblue'>封装原则：</font>

- 将不需要对外公共提供的内容隐藏起来
- 把属性隐藏，提供公共方法对其访问



### private关键字

<font color='cornflowerblue'>特点：</font>

- 是一个权限修饰符：在本类中可用
- 可以修饰成员变量和成员方法
- 被修饰的成员只能在本类中使用

### this关键字

<font color='cornflowerblue'>特点：</font>代表当前对象

如:	<font color='red'>this</font>==>Student <font color='red'>s</font>=new Student();

上面的this即代表s

<font color='cornflowerblue'>应用：</font>代表当前类，用来区分成员变量和局部变量

### 构造方法

<font color='cornflowerblue'>概述：</font>给对象的属性进行初始化赋值

<font color='cornflowerblue'>格式：</font>方法名和类名相同，没有返回值，void也没有

<font color='cornflowerblue'>注意：</font>当没有显示给出有参构造函数时，系统自动隐式生成无参构造函数，如果已经有了有参构造函数，系统不再自动生成无参构造函数，一般无参构造函数也会手动给出，方便后面调用。

构造重载：

- 方法名与类名相同
- 参数列表：1长度不同，2位置不同，3参数类型不同
- 方法重载与返回值无关

### static关键字

<font color='cornflowerblue'>特点：</font>

- 随着类加载而加载
- 静态优先于对象
- 被类的所有对象共享
- 可以通过类名调用，本身可以通过对象调用，推荐使用类名调用，静态装饰的内容我们一本称它为与类相关的，类成员
- ![image-20210917080006998](E:\Typora图片仓库\image-20210917080006998.png)

![](https://i.loli.net/2021/09/16/fHgzycYsr1UWwQC.png)

今日练习：

![image-20210916150523830](E:\Typora图片仓库\image-20210916150523830.png)

创建对象步骤逻辑:

------

### 成员变量和静态变量的区别

1. 所属不同
    - 成员变量属于对象，也称实例变量（对象变量）
    - 静态变量属于类，也称类变量
2. 内存中位置不同
    - 静态成员存储在方法区的静态区
    - 成员变量储存在堆内存中
3. 在内存中出现的时间不同
    - 静态成员变量随着类加载而加载
    - 成员变量随着对象的创建而存在
4. 调用不同
    - 静态可以通过类名调用，也可以通过对象调用
    - 成员变量只能通过对象调用

### main方法和格式

```java
public static void main(String[] args){}
```

- public：被JVM调用，访问权限足够大
- static:   被JVM调用，不用创建对象，直接类名访问较快
- void：被JVM调用，不需要给JVM返回值
- main:  一个通用名称，虽不是关键字，但是被JVM识别
- String[] args: 以前用于接收键盘的输入



### 继承

特点：

- Java只支持单继承，不支持单继承
- Java支持多层继承

好处：

- 让类与类之间产生了关系，是多态的前提
- 提高代码的复用性和维护性

弊端：类的耦合性增强了

开发原则：高内聚，低耦合

内聚：就是自己完成某件事的能力

耦合：类与类的关系

注意：

- 子类只能继承父类中
- 子类不能继承父类的构造方法，可以通过super关键字去访问父类的构造方法
- 不要为了部分功能而去继承

使用场景：  

继承体现的是is  a的关系

假设：我们有两个类A,B，只有符合a是b的一种，或者b是a的一种，这样的情况下可以用继承、

继承中成员变量的关系：不同名的变量，同名的变量

this和super的区别和应用

**super**

子类局部范围访问父类成员变量

使用区别：

1. ​	调用成员变量
    - this	成员变量调用本类的的成员变量，也可以调用父类的成员变量（如果父类和子类中有同名的成员变量，那么调用子类）
    - super   成员变量，调用父类的成员变量
2. 调用构造方法
    - ​	this(...)调用本类的构造方法
    - ​    super(...)调用父类的构造方法
3.  成员方法调用
    - this.成员方法		调用本类的成员方法，也可以调用父类的成员方法
    - super.成员方法      调用父类的成员方法

### 基础中构造方法的关系

静态代码块，构造代码块，构造方法

静态代码块在类加载的时候运行

构造代码块在构造方法之前运行

子类先调用父类的构造方法，在调用本身的构造方法。

### 方法重写

概述：子类父类中出现了同名方法（返回值必须一致，返回值类型可以是子类也可以是父类）

应用：当子类需要父类的功能，而功能主

体子类特有自己的功能的时候，可以重写。

<font color='yellow'>注意事项：</font>

- 父类中私有方法不能重写，因为私有方法根本无法继承
- 子类重写父类方法时访问权限要高于或者等于父类，最好一致
- 父类如果是静态的方法，子类必须用静态方法进行重写。



<font color='cornflowerblue'>重载overlord和重写override的区别：</font>

- 方法重写：子类中出现和父类同名方法。且参数（长度一致，顺序一致，类型一致），返回值相同
- 方法重载：本类中出现了方法名相同，且参数（长度不同，顺序不同，类型不同），与返回值无关。

------





### final关键字



### 多态

概述：事物存在的多种形态

前提：

要有继承关系

要有方法重写

要有父类引用指向子类对象



![image-20210918094009644](E:\Typora图片仓库\image-20210918094009644.png)

操作符多态:	同一个操作符在不同情景下，具备不同的作用。

 多态成员访问特点：

成员变量：编译看左边，运行看左边

![image-20210918100604343](E:\Typora图片仓库\image-20210918100604343.png)

![image-20210918100615925](E:\Typora图片仓库\image-20210918100615925.png)

成员方法：编译看左边，运行看右边

![image-20210918102013615](E:\Typora图片仓库\image-20210918102013615.png)

静态成员：	

![image-20210918104657226](E:\Typora图片仓库\image-20210918104657226.png)

多态好处：

- 提高了代码的维护性（继承保证）
- 提高了代码的扩展性（多态保证)

 弊端：不能使用子类特有的属性和行为

------

### 抽象类

<font color='cornflowerblue'>概述</font>：即看不懂的类

<font color='cornflowerblue'>特点</font>：抽象类和抽象方法都必须有一个关键字<font color='orange'>abstract</font>

<font color='cornflowerblue'>格式</font>：类:	abstract class 类名{}

​		方法:	public abstract void  aa()

- 抽象类中不一定有抽象方法，有抽象方法的一定是抽象类或者接口
- 抽象类不能实例化，抽象类如何实例化呢？（按照多态的变化，父类引用指向子类对象
- 抽象类的子类，要么抽象类，要么是写抽象类中所有的抽象方法。 

<font color='cornflowerblue'>成员特点</font>:

- 成员变量既可以是变量，也可以是常量，abstract不可以修饰变量；
- 有构造方法，用于子类访问父类数据初始化；
- 成员方法，既可以是抽象，也可以是非抽象

<font color='cornflowerblue'>特征</font>:

抽象方法：强制要求子类完成的；非抽象方法：子类继承的事情，提高代码的复用性。

### 接口

<font color='cornflowerblue'>概述</font>：
狭义角度：interface在java中
广义角度；对外提供规则的都是接口

<font color='cornflowerblue'>特点</font>：
接口用关键字interface表示
格式:	interface 接口名{}

类实现接口：implements
格式: class 类名 implements 接口名称1， 接口名称2....

接口不能实例化（如果一定要实例化？按照多态的思想）

<font color='cornflowerblue'>接口的子类</font>：
可以是抽象类，意义不大；
可以是具体的实现类，要重写接口中的所有抽象方法。

接口的成员特点:
成员变量：只能是常量
默认修饰符：public static final 建议手动给出
构造方法；接口中没有构造方法
成员方法：只能是抽象方法，有默认修饰符，public abstract建议手动给出

练习：
![image-20210918152742548](E:\Typora图片仓库\image-20210918152742548.png)

答：类与类之间可以有继承关系，类与接口可以是实现和被实现的关系；接口和接口之间可以是继承关系。


### 引用

概念：如果一个变量的类型不是基本类型，而是类 类型，那么该变量叫做引用

假如有一个Student类，<font color='limegreen'>new Student()</font>代表创建了一个对象，但这仅仅是创建了一个对象，你是没有办法访问它的，那我们要怎么样才能访问到它呢？

这时候我们就要用到<font color='orange'>引用</font>来<font color='orange'>代表</font>这个对象

> <font color='limegreen'>Student s=new Student()</font>

上面的变量s就是Student类型，又称引用，“=”的意思是s这个引用代表右侧new Student()创建的对象好，又称引用s指向Student对象

**多个引用，一个对象**

如：

> <font color='limegreen'>Student s1=new Student();</font>
>
> <font color='limegreen'>s2=s1;</font>
>
> <font color='limegreen'>s3=s2;</font>



上面的s3,s2,s1都是指向同一个对象

**一个引用，多个对象**

一个引用任何时候只能指向一个对象

如：

> <font color='limegreen'>Student s=new Student()</font>
>
> <font color='limegreen'>s=new Student()</font>

上面的例子中new student()将丢失。

图例：

![image-20210916154255623](E:\Typora图片仓库\image-20210916154255623.png)







简洁总结：

封装：<font color='orange'>隐藏实现细节，提供简化接口</font>

